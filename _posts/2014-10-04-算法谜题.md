---
layout: post
---
#算法谜题

[美] Anany Levition, Maria Levitin 著

##概览

算法设计的若干通用策略和分析技术。

无论算法题的形式是具体的还是一般的，先拿少数几种情况尝试尝试，几乎总不会错。

###回溯法

backtracking，核心思想在于，采用一次添加一个组件的办法来构造解，并且如下评估可能解的“半成品”：

- 如果这个构造到一半的解可以再向前推进一步而不违反题设的约束，则选择第一个合法选项作为下一个部件；
- 如果找不到合法选项作为下一个部件，那么久不再需要去考虑任何其余部件了。在这种情况下，算法就要执行回溯，把当前构造到一半的解的最后一个部件替换成该部件可选的下一个合法选项。

状态空间树（state-space tree），其中的叶节点有两种可能的类型：

- 无望节点/死路节点，其对应的是那些不可能达成解的“半成品”，一旦构造出了无望达成解的结点，回溯算法就会中止该节点（剪枝）；
- 解节点，如果搜索到一个解，算法会就此终止，如果还需要搜索其他的解，则算法回溯到叶节点的父节点，继续搜索下去。

而对于每一个可以采用回溯法求解的问题，都应该努力寻找某种更有效的算法。

###减而治之 decrease-and-conquer

该策略的基础，在于从给定问题的解及其较小规模谜面的解之间找到某种关系，一旦找到，这样的关系就可以自然而然地导向某种递归算法，它可以将问题减少为一系列的、规模越来越小的谜面，直至可以一下子解决为止。

有时候，通过自底而上的方法来发掘较大和较小问题之间的关系，可能会更简单。这就是说，先把谜题的最小规模谜面解出，然后再看第二小的，依此类推。这种方法成为增量法（incremental approach）。

###分治（divide-and-conquer）

把一个问题划分成若干较小的子问题，然后各个击破，最后在必要时把子问题的解组合起来，就得到了原始问题的解。

其与减治法的区别在于：分治法每一步需要解决多个子问题，而减治法仅需要解决一个。

###变治 transform-and-conquer

- 谜面简化：首先将问题的一个谜面变换成同样问题的另一个谜面，而该谜面具备某种特殊性使得问题较易求解，如此将问题解出；
- 表示变更：把问题的输入变换成另一种表示，从而更有助于找到有效算法来求解；
- 问题规约：把给定问题的谜面整体转化为另一个问题的谜面。

###贪心法 greedy approach

步步为营，每一步怎么走，取决于如何能够产生最大的短期收益并且不违反题设的约束。

###迭代 iterative improvement

- 值只会向一个期望的方向改变；
- 只存在有限个值，这就保证了在有限步以后算法必会中止。

这种特质称为单变性。

###动态规划 dynamic programming

用来解决有着彼此重叠子问题的问题。其解法是只对较小规模的子问题求解一次，然后把结果记录在一个表格中。而原问题的解就可以从表格中得到。

对于欲用本方法求解的最优化问题而言，问题必须具备所谓的最优子结构，只有这样，才能从子问题的最优解有效地构造出全局最优解。

###算法分析

做算法分析的目的通常是为了确定算法的时间效率。

**非递归算法分析**

对其主要步骤数目求和，然后，将该和简化为一个精确的计数公式，或一个表达其增长速率的估算公式。

**递归算法分析**

递归关系式，表明了数列的第n项与它的前项之间的关系。

**不变量 invariant**

就是在任何一个算法在解题时保持不变的某种性质。不变量经常用来说明某个问题无解，因为称为不变量的性质在谜题的初始状态成立，而在所要求的终止状态却并不成立。

一般地，奇偶配对以及着色，是运用不变量思想时用得最广的两种方法。

七桥问题，就是在多重图中查找是否存在一条Euler回路：一个邻接顶点的序列，它在回到起始顶点前遍历了所有的边仅一次。

符合这种要求的回路中，进入一个顶点的次数必须恰好等于离开该顶点的次数。也就是说，若要多重图中存在这种回路，就必须满足接触顶点的边数——顶点的度数——对于所有顶点而言皆为偶数。这个不变量性质决定了七桥问题无解。

