---
layout: post
---
#分布式系统之同步

与同步相关的是分布式系统中的互斥和分布式事务。

##时钟同步

###物理时钟

计算机上都有一个计时器（timer）。

一旦引入多CPU系统，每个CPU都有自己的时钟，尽管石英晶体震荡的频率通常是相当稳定的，但仍不可能保证不同计算机中的石英晶体都以完全相同的频率在振荡。

当同时读这些时钟值时，将得到不同的值。这种时间值的不同称为时钟偏移。

两个问题：

- 如何使它们与真实世界的时钟同步呢？
- 如何使这些时钟彼此同步？

UTC（universal coordinated time）

###时钟同步算法

**Cristian算法**

适合于只有一台机器上有WWV接收器，而其他所有机器都要与这台机器同步的系统。

那台拥有WWV接收器的机器称为时间服务器（time server），每台机器以一定的周期定期向时间服务器发送消息询问当前时间。时间服务器接到消息后就尽快发送含有当前时间的消息来应答。

这种方法有两个问题：

- 时间绝不能倒退，如果请求者的时间比UTC时间要快，那也不能一下子就退回去，而是要逐步进行，一点一点慢下来；
- 从时间服务器发送的应答到达发送请求者需要花费一定时间，发送者记录下来发送请求的起止时间，来更加精确地计算出收到请求时的时间。

**Berkeley算法**

在上一个算法中，时间服务器是被动的。

Berkeley UNIX系统采取了相反的方法，该系统中的时间服务器是主动的，它定期地询问每台机器的时间。基于这些回答，它计算出一个平均时间，并告诉所有其他机器将它们的时钟拨快到一个新的时间，或者拨慢，直到某个指定的减少量达到为止。

这种方法适合于没有WWV接收器的系统。时间守护程序的时间必须由操作者定期手工设置。

**平均值算法**

以上两种算法都是集中式的，可以用一些分布式算法，一种非集中式时钟同步算法是将时间划分成固定长度的再同步间隔。在每次间隔的开始处，每台机器根据自己的时钟广播当前时间。由于不同机器上的时钟不可能完全同速工作，所以这些广播将不会正好同时发生。

在一台机器广播了它的时间后，它启动本地计时器接收在某个时间间隔S里到达的其他所有广播。当所有广播到达后，执行一个算法从这些值中计算得到一个新的时间值。最简单的算法是取其他所有机器值的平均值。

变种一：先除去m个最高值和m个最低值，然后取剩下的平均值。丢弃两端值可认为是一种自我保护措施，以防受到2m个错误时钟发出的毫无意义的时间值的影响。

变种二：给每条消息加上一个从源到目的地的传送时间的估计值，该估计值可参考网络的拓扑结构，或统计探测消息的响应时间而得到。

**多个外部时间源**

##逻辑时钟

通常重要的不是所有的进程在时间上完全一致，而是它们在事件的发生顺序上要达成一致。

###Lamport时间戳

先发生关系（happens-before）的两种情况：

- 如果a和b是同一个进程中的两个事件，且a在b之前发生，则a->b为真；
- 如果a是一个进程发送消息的事件，而b为另一个进程接收这个消息的事件，则a->b也为真。

先发生关系是一种传递关系。如果两个事件发生在两个互不交换消息的进程中，那么x->y与y->x都不真，这两个事件称为并发的。

Lamport方法：每个消息都应携带依据发送者时钟的发送时间。当消息到达并且接收者时钟显示的时间值比消息的发送时间早时，接收者就将它的时钟调到一个比发送时间大1的值。

补充：在每两个事件之间，时钟必须至少滴答一次，如果一个进程以相当快的速度连续发送或接收两个消息，那么它的时钟必须在这之间至少滴答一次。

附加条件：两个事件不会精确地同时发生。可以将事件发生所在的进程号附加在时间的低位后，并用小数点分开。

分布式系统中所有事件分配时间的方法规则：

- 若在同一进程中a在b之前发生，则C(a)<C(b)；
- 若a和b分别代表发送一个消息和接收该消息的事件，则C(a)<C(b)；
- 对于所有不同的事件a和b，C(a)!=C(b)。

**全序多播**

totally-ordered multicast，一次将所有的消息以同样的顺序传送给每个接收者的多播操作。

考虑一组彼此互相多播消息的进程，每个消息都以它的发送者的当前逻辑时间作为时间戳。进程接收到一个消息后，将它放进一个本地队列中，并根据它的时间戳进行排序，然后接收者向其他所有进程广播一个确认消息。

所有进程最终都将有相同的本地队列拷贝。

###向量时间戳 Vector timestamp

##选举算法

许多分布式算法需要一个进程充当协调者、发起者或者其他某种特殊的角色。通常，由哪个进程充当这个特殊的角色并不重要，重要的是它们中要有一个进程来充当。

如果所有的进程都完全相同，没有任何区别，那么就无法选择其中一个作为特殊进程。因此，我们假设每个进程有一个唯一的编号。通常，选举算法试着找出进程号最大的进程，将它指定为协调者。

假设每个进程都知道所有其他进程的进程号。但进程并不知道当前哪些进程正在运行，以及哪些进程崩溃了。选举算法的目标是确保发起选举后，当所有的进程都同意选出的新协调者时选举结束。

###欺负算法 Bully

当任何一个进程发现协调者不再响应请求时，它就发起一次选举。进程P按如下过程主持一次选举：

- P向所有编号比它大的进程发送一个ELECTION消息；
- 如果无人响应，P获胜成为协调者；
- 如果有编号比它大的进程响应，则由响应者接管选举工作。P的工作完成。

任何时刻，一个进程只能从编号比它小的进程得到一个ELECTION消息。当该消息到达时，接收者发回一个OK消息给发送者，表明它仍然在运行，并且接管选举工作。然后接收者主持一个选举。最终，除了一个进程外，其他所有进程都将放弃，那个进程就是新的协调者。它将选举获胜的消息发送给所有进程，通知它们自己是新的协调者。

当一个以前崩溃了的进程现在恢复过来时，它将主持一次选举。如果该进程恰好是当前正在运行的进程中进程号最大的进程，它将赢得此次选举，接管协调者的工作。这样，最大的进程总是取胜，故称为“欺负算法”。

###环算法 ring

该算法不使用令牌，假设进程按照物理或逻辑顺序进行了排序，那么每个进程就都知道它的后继者是谁了。当任何一个进程注意到协调者不工作时，它就构造一个带有它自己的进程号的ELECTION消息，并将该消息发送给它的后继者。如果后继者崩溃了，发送者沿着此环跳过它的后继者发送给下一个进程，或者再下一个，直到找到一个正在运行的进程。在每一步中，发送者都将自己的进程号加到消息列表中，以使自己成为协调者的候选人之一。

最终，消息返回到发起此次选举的进程。当发起者进程接收到一个包含它自己进程号的消息时，它识别出这个事件。此时，消息类型变成COORDINATOR消息，并再一次绕环运行，向所有进程通知谁是协调者（成员列表中进程号最大的那个）以及新环中的成员都有谁。这个消息在循环一周后被删除，随后每个进程都恢复原来的工作。

##互斥

###集中式算法

在分布式系统中达成互斥的最直接的方法是仿照单处理器系统中的方法，选举一个进程作为协调者，无论何时一个进程要进入临界区，它都要向协调者发送一个请求消息，说明它想要进入哪个临界区并请求允许。如果当前没有其他进程在该临界区内，协调者就发送允许进入的应答消息。收到应答后，该请求进程即进入临界区。

当已有进程在临界区，协调者可以有两种方式处理请求：

- 不应答，阻塞请求者进程；
- 发送一个“拒绝请求”的应答；

将请求放入队列中，等待更多的请求消息过来。

当进程退出临界区时，它向协调者发送一个消息以让协调者释放它的独占访问，协调者从消息队列中取出第一个进程，并向该进程发送一个允许进入消息。

缺点：单个协调者会成为性能的瓶颈。

###分布式算法

该算法的前提是所有事件都是完全排序的，Lamport算法是一种完成这种排序的方法，该算法还能用于为分布式互斥提供时间戳。

该算法的工作过程如下：当一个进程想要进入一个临界区时，它构造一个消息，其中包含它要进入的临界区的名字，它的进程号和当前时间。然后它将该消息发送给所有其他进程。假设消息的传送是可靠的，也就是说，每个消息都能得到确认。

当一个进程接收到来自另一个进程的请求消息时，它根据自己与消息中的临界区相关的状态来决定它要采取的动作：

- 若接收者不在临界区也不想进入临界区，它就向发送者发送一个OK消息；
- 若接收者已经在临界区中，它不进行应答，而是将该请求放入队列中；
- 如果接收者想进入临界区但尚未进入时，它将对收到的消息的时间戳与包含在它发送给其他进程的消息中的时间戳进行比较。时间戳最早的那个进程获胜。如果收到的消息的时间戳比较早，那么接收者向发送者发回一个OK消息。如果它自己的消息的时间戳比较早，那么接收者将收到的请求放入队列中，并且不发送任何消息。

在发送了请求进入临界区的请求消息后，进程进行等待，直到其他所有进程都发回了允许进入消息为止。一旦得到所有进程的允许，它就可以进入临界区了。当它退出临界区时，它向其队列中的所有进程发送OK消息，并将它们从队列中删除。

###令牌环算法

可以用软件的方法构造出一个逻辑环，环中每个进程都分配了一个位置，环的位置按照什么顺序进行排列并不重要，重要的是每个进程要知道谁在它的下一个位置上。

当环初始化时，进程0得到一个令牌（token），该令牌绕着环运行，用点对点发送消息的方式把它从进程k传到进程k+1（以环大小为模）。进程从它邻近的进程得到令牌后，检查自己是否要进入临界区，如果自己要进入临界区，那么它就进入临界区，做它要做的工作，然后离开临界区。在该进程退出临界区后，它沿着环继续传递令牌。不允许使用同一个令牌进入另一个临界区。

由于令牌以固定顺序在进程间循环传递，所以不会发生饿死现象。

问题所在：如果令牌丢失了，那么就必须重新生成令牌。实际上，检测令牌丢失是很困难的，这是因为网络中令牌两次出现的时间间隔是不确定的。

如果有进程崩溃了，可以要求每个进程在收到令牌后发出确认消息，那么当一个进程的邻近进程试图把令牌传递给它但没有成功时，这个崩溃的进程就会被检测到。

###三种算法比较

- 集中式算法，简单有效，三个消息：一个请求进入消息、一个允许进入消息和一个释放退出消息；
- 分布式算法，一个进程向其他每个进程发送一个请求进入消息，这样需要n-1个请求进入消息，还有另外n-1个允许进入消息，共2(n-1)个消息；
- 令牌环算法，消息数目是可变的。

##分布式事务

互斥算法保证了某一时刻至多一个进程访问一个共享资源，事务同样也保护一个共享资源不会被几个并发进程同时访问。

另外，事务允许进程把访问和修改数据项作为一项单独的原子操作来完成。如果进程在事务处理期间中途退出，所有数据都恢复到事务开始前的状态。

###事务模型

使用事务进行编程需要一些专门的原语，这些原语或者由底层分布式系统提供，或者由语言的运行时系统提供。

常用的原语有：

- BEG_IN_TRANSACTION，标志事务的开始
- END_TRANSACTION，终止事务并试着提交
- ABORT_TRANSACTION，销毁事务并恢复原来的值
- READ，从文件、表或者其他地方读数据
- WRITE，向文件、表或者其他地方写数据

事务的4个特性ACID：

- 原子性（atomic），事务的发生是不可分割的
- 一致性（consistent），事务不能破坏系统的恒定性
- 独立性（isolated），并发的事务不会互相干扰
- 持久性（durable），一旦事务得到了提交，改变将是永远存在的

原子性，保证了每个事务要么全部发生，要么全部不发生。如果发生，事务是不可分割的瞬间动作，当一个事务正处于执行中时，其他进程看不到任何中间状态。

###事务的分类

- 单层事务
- 嵌套事务
- 分布式事务

嵌套事务是一个按照逻辑关系分解成一层层子事务的事务。

分布式事务逻辑上是一个单层的，不可分割的事务，它的操作对象是分布式的数据。

###实现

**私有工作空间**

当一个进程开始一个事务时，它被分配一个私有工作空间，该工作空间包含所有它有权访问的文件。在事务提交或中止前，它的所有读写操作都在私有工作空间内进行，而不是直接对文件系统进行操作。

**写前日志 writeahead log**

文件将真正被修改，但是在任何一个数据块被修改前，一条记录被写到了日志中以说明哪个事务正在对文件进行修改，哪个文件和哪个数据块被改动了，旧值和新值各是什么。只有当日志被成功写入后，此改动才可以被写入文件。

###并发控制

并发控制的目的是允许几个事务同时执行，但是被操作的数据项集合要保持一致的状态。

**串行性**

并发控制算法的主要目的是保证多个事务可以同时被执行并且仍然保持独立，这意味着最终的执行结果跟事务以某种特定顺序一个接一个串行执行得到的结果相同。

并发控制的总体思想是正确地调度相冲突的操作。如果两个操作都是对同一个数据项进行操作，并且至少一个是写操作，那么这两个操作就互相冲突。

并发控制算法通常根据读写操作同步的方法来分类，同步可以通过共享数据上的互斥机制（如锁定），或者通过显试地使用时间戳排序来实现。

- 悲观算法：操作是在它们被执行前同步的，这意味着冲突在允许发生之前就解决了；

- 乐观算法：基于错误一般不会发生的观点，操作被简单地执行，在事务结束的时候再进行同步，如果那时确实发生了冲突，一个或更多的事务将被迫中止。

**两阶段锁定**

用锁来提供串行调度的算法，可以用两阶段锁定算法。

两阶段锁定（two-phase locking, 2PL），调度管理器先在增长阶段（growing phase）获得它所需要的所有锁，而在收缩阶段（shrinking phase）释放它们。

如果所有事务都使用两阶段锁定，那么通过交错执行事务所形成的调度都是串行的。

严格的两阶段锁定（strict two-phase locking）

两阶段锁定和严格的两阶段锁定都可能导致死锁。如果两个进程都试图获得同一对锁，但是它们是以相反的顺序请求，那么就可能导致死锁。这可采用一般性的技术来解决，比如以某种规范的顺序获得所得的锁以免出现保持——等待循环。

- 集中式2PL，由一个站点负责允许加锁和释放锁
- 基本的2PL，
- 分布式2PL

**悲观的时间戳排序**

在每个事务T开始时给它分配一个时间戳ts(T)，使用Lamport算法，可以保证时间戳是唯一的。事务T的每个操作都被盖上时间戳ts(T)，并且系统中的每个数据项x都有一个相关的读时间戳tsRD(x)和tsWR(x)，读时间戳被设置为最近读x的事务的时间戳，而写时间戳是最近修改x的事务的时间戳。使用时间戳排序，如果两个操作冲突，则数据管理器先处理时间戳更早的操作。

这种方式不会造成死锁。

**乐观的时间戳排序**

此技术的思想：不关心别人在干什么，继续做自己要做的事，如果有问题，等到后面再考虑。

乐观的并发控制所做的事情是跟踪哪些数据项被读写了，在某个事务提交的时候，它检查其他所有事务，看看是否这些数据项中的某些从这个事务开始后已经被改变了。如果被改变了，该事务被中止。如果没有被改变，该事务就被提交。

优点：不会发生死锁，允许最大的并行性。



