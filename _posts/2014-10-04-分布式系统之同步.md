---
layout: post
---
#分布式系统之同步

与同步相关的是分布式系统中的互斥和分布式事务。

##时钟同步

###物理时钟

计算机上都有一个计时器（timer）。

一旦引入多CPU系统，每个CPU都有自己的时钟，尽管石英晶体震荡的频率通常是相当稳定的，但仍不可能保证不同计算机中的石英晶体都以完全相同的频率在振荡。

当同时读这些时钟值时，将得到不同的值。这种时间值的不同称为时钟偏移。

两个问题：

- 如何使它们与真实世界的时钟同步呢？
- 如何使这些时钟彼此同步？

UTC（universal coordinated time）

###时钟同步算法

**Cristian算法**

适合于只有一台机器上有WWV接收器，而其他所有机器都要与这台机器同步的系统。

那台拥有WWV接收器的机器称为时间服务器（time server），每台机器以一定的周期定期向时间服务器发送消息询问当前时间。时间服务器接到消息后就尽快发送含有当前时间的消息来应答。

这种方法有两个问题：

- 时间绝不能倒退，如果请求者的时间比UTC时间要快，那也不能一下子就退回去，而是要逐步进行，一点一点慢下来；
- 从时间服务器发送的应答到达发送请求者需要花费一定时间，发送者记录下来发送请求的起止时间，来更加精确地计算出收到请求时的时间。

**Berkeley算法**

在上一个算法中，时间服务器是被动的。

Berkeley UNIX系统采取了相反的方法，该系统中的时间服务器是主动的，它定期地询问每台机器的时间。基于这些回答，它计算出一个平均时间，并告诉所有其他机器将它们的时钟拨快到一个新的时间，或者拨慢，直到某个指定的减少量达到为止。

这种方法适合于没有WWV接收器的系统。时间守护程序的时间必须由操作者定期手工设置。

**平均值算法**

以上两种算法都是集中式的，可以用一些分布式算法，一种非集中式时钟同步算法是将时间划分成固定长度的再同步间隔。在每次间隔的开始处，每台机器根据自己的时钟广播当前时间。由于不同机器上的时钟不可能完全同速工作，所以这些广播将不会正好同时发生。

在一台机器广播了它的时间后，它启动本地计时器接收在某个时间间隔S里到达的其他所有广播。当所有广播到达后，执行一个算法从这些值中计算得到一个新的时间值。最简单的算法是取其他所有机器值的平均值。

变种一：先除去m个最高值和m个最低值，然后取剩下的平均值。丢弃两端值可认为是一种自我保护措施，以防受到2m个错误时钟发出的毫无意义的时间值的影响。

变种二：给每条消息加上一个从源到目的地的传送时间的估计值，该估计值可参考网络的拓扑结构，或统计探测消息的响应时间而得到。

**多个外部时间源**

##逻辑时钟

通常重要的不是所有的进程在时间上完全一致，而是它们在事件的发生顺序上要达成一致。

###Lamport时间戳

先发生关系（happens-before）的两种情况：

- 如果a和b是同一个进程中的两个事件，且a在b之前发生，则a->b为真；
- 如果a是一个进程发送消息的事件，而b为另一个进程接收这个消息的事件，则a->b也为真。

先发生关系是一种传递关系。如果两个事件发生在两个互不交换消息的进程中，那么x->y与y->x都不真，这两个事件称为并发的。

Lamport方法：每个消息都应携带依据发送者时钟的发送时间。当消息到达并且接收者时钟显示的时间值比消息的发送时间早时，接收者就将它的时钟调到一个比发送时间大1的值。

补充：在每两个事件之间，时钟必须至少滴答一次，如果一个进程以相当快的速度连续发送或接收两个消息，那么它的时钟必须在这之间至少滴答一次。

附加条件：两个事件不会精确地同时发生。可以将事件发生所在的进程号附加在时间的低位后，并用小数点分开。

分布式系统中所有事件分配时间的方法规则：

- 若在同一进程中a在b之前发生，则C(a)<C(b)；
- 若a和b分别代表发送一个消息和接收该消息的事件，则C(a)<C(b)；
- 对于所有不同的事件a和b，C(a)!=C(b)。

**全序多播**

totally-ordered multicast，一次将所有的消息以同样的顺序传送给每个接收者的多播操作。

考虑一组彼此互相多播消息的进程，每个消息都以它的发送者的当前逻辑时间作为时间戳。进程接收到一个消息后，将它放进一个本地队列中，并根据它的时间戳进行排序，然后接收者向其他所有进程广播一个确认消息。

所有进程最终都将有相同的本地队列拷贝。

###向量时间戳

