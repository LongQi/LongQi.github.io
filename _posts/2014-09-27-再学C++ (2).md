---
layout: post
---
#再学C++ 之 STL

STL三个基本组件：

- 迭代器
- 容器，如：list, vector, map等
- 算法：是用来操作容器中的数据的模板函数，如sort(), find()等

STL头文件：

- <deque\>
- <list\>
- <map\>
- <queue\>
- <set\>
- <stack\>
- <vector\>

名字空间：STL的sort()以及其他标志符都封装在名字空间std中，例如：STL的sort()算法编译为：std::sort()，从而避免了名字冲突。

	using namespace std;

##迭代器

迭代器提供对一个容器中的对象的访问方法，并且定义了容器中对象的范围，迭代器就如同一个指针。事实上，C++的指针也是一种迭代器。

作为指针，必须能够使用*操作符来获取数据，还可以使用操作符如++，用来递增迭代器，以访问容器中的下一个对象。如果迭代器到达了容器中的最后一个元素的后面，则迭代器变成past-the-end值。

###迭代器的类型

对于STL数据结构和算法，可以使用五种迭代器：

- Input iterators 提供对数据的只读访问；
- Output iterators 提供对数据的只写访问；
- Forward iterators 提供读写操作，并能向前推进迭代器；
- Bidirectional iterators 提供读写操作，并能向前和向后操作；
- Random access iterators 提供读写操作，并能在数据中随机移动。

###容器迭代器

	vector<int> intVector(100);
	intVector[20]=50;

	vector<int>::iterator intIter = find(intVector.begin(), intVector.end(), 50);

	cout<<*intIter<<endl;

###常量迭代器

和指针一样，可以给一个迭代器赋值，例如：首先申明一个迭代器：

	vector<int>::iterator first;

下面的语句将迭代器设置到intVector的第一个对象，并将它指向的对象值设置为123:

	first = intVector.begin();
	*first = 123;

##容器

###vector 向量

可以用常数时间访问和修改任意元素，在序列尾部进行插入和删除时，具有常数时间复杂度，对任意项的插入和删除就有的时间复杂度与到末尾的距离成正比，尤其对向量头的添加和删除的代价是惊人的高的。

###deque 双端队列

基本上与向量相同，唯一不同是，其在序列头部插入和删除操作也具有常量时间复杂度。

###list 表

对任意元素的访问与对两端的距离成正比，但对某个位置上插入和删除一个项的花费为常数时间。

###queue 队列

插入只可以在尾部进行，删除、检索和修改只允许从头部进行。按照先进先出的原则。

###stack 堆栈

堆栈是项的有限序列，并满足序列中被删除、检索和修改的项只能是最近插入序列的项，即按照后进先出的原则。

###set 集合

由节点组成的红黑树，每个节点都包含着一个元素，节点之间以某种作用于元素对的谓词排列，没有两个不同的元素能够拥有相同的次序，具有快速查找的功能，但是它是以牺牲插入删除操作的效率为代价的。

###multiset 多重集合

和集合基本相同，但可以支持重复元素具有快速查找能力。

###map 映射

由{key, value}对组成的集合，以某种作用于键对上的谓词排列。具有快速查找能力。

###multimap 多重映射

比起映射，一个键可以对应多个值，具有快速查找能力。

##容器

序列容器：

- vector
- list
- deque

容器适配器

- queue
- stack
- priority_queue

关联式容器

- set
- map
- multiset
- multimap

针对不同的需要使用不同的模型，序列容器仅将它们的元素线性地组织起来，是最基本的容器类型。对于某些问题，这些序列需要附上某些特殊的属性，这正好是容器适配器要做的事——它们对诸如队列或栈的抽象建立模型。关联式容器则基于关键字来组织它们的数据，并允许快速地检索那些数据。

标准库中所有的容器都持有存入的对象的拷贝，并且根据需要扩展它们的资源，所以这些对象都必须是可构造拷贝（具有一个可访问的拷贝构造函数）和可赋值拷贝（具有一个可访问的赋值操作符）的。

所有的迭代器都可以在它们的序列中向前移动（通过运算符operator++），并且允许使用==和!=进行比较。通过使用解析运算符（operator*），一个迭代器可用于产生其当前所指的容器元素。

一个容器也可以是可逆的（reversible），这意味着容器可以产生一个从末尾反向移动的迭代器，这些迭代器也可以从容器的起始元素前向移动。所有标准的容器都支持这种双向迭代。

可逆容器拥有成员函数rbegin()和rend()。迭代器为reverse_iterator.

